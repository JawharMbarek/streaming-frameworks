\chapter{Schlussbetrachtung}
\label{sec:schlussbetrachtung}

Im Kapitel zuvor wurde die Evaluierung der Prototypen Apache Storm, Apache Kafka, Apache Flume und Apache S4 durchgeführt. In diesem Kapitel werden alle Kapitel zusammengefasst und ein Ausblick gegeben. Zuerst wird eine differenzierte Zusammenfassung aus den vorhergehenden Kapitel gegeben. Abschließend werden im Ausblick mögliche Erweiterungen und Optimierungsmöglichkeiten aufgezeigt.

\section{Zusammenfassung}

In dieser Arbeit werden die Streaming Frameworks Apache Storm, Apache Kafka, Apache Flume und Apache S4 verglichen. Dazu wird zuerst in das Thema eingeführt und die Grundlagen geschaffen. Um Gemeinsamkeiten zwischen den Streaming Frameworks festzustellen werden Kriterien im Kapitel \ref{chapter:kriterien} vorgestellt und an einem Referenzmodell angewendet. Anschließend werden
die einzelnen Streaming Frameworks vorgestellt und durch die vorgestellten Kriterien aus dem Kapitel zuvor angewendet. In den folgenden Kapiteln wird aufbauend auf der Vorstellung der Streaming Frameworks die Systemarchitektur vorgestellt. Mit der Deklaration der Systemarchitektur werden die Prototypen zu den einzelnen Streaming Frameworks erstellt und im Kapitel Prototypdokumentation dokumentiert. Nach der Implementierung der Prototypen wird im Kapitel Evaluierung der Messaufbau vorgestellt, eine Messung durchgeführt und die Messergebnisse vorgestellt. Weiterhin werden die Messergebnisse diskutiert und bewertet. Als nächstes werden die einzelnen Kapitel zusammengefasst.

In Kapitel \ref{chapter:einfuehrung} wird eine Einführung in das Thema anhand verschiedener Anwendungsfälle wie zum Beispiel dem Verlust einer Kreditkarte gegeben. Nach der Vorstellung der Beispiele wird der Aufbau dieser Arbeit erklärt und in das Kapitel \nameref{chapter:grundlagen} eingeleitet. Im Kapitel \ref{chapter:grundlagen} werden für den Vergleich der Streaming Frameworks Grundbegriffe eingeführt und in einen Bezug gebracht. Dabei wird der allgemeine Nachrichtenaustausch aufgezeigt, der Begriff \textit{Streaming} abgegrenzt und der Begriff \textit{Frameworks} erklärt. Weiterhin wird eine Berechnung in einem Streaming Framework anschaulich beschrieben. Anhand eines Graphen werden Abfragen in einem Streaming Framework illustriert und erläutert.

Das Kapitel \ref{chapter:kriterien} stellt den Big Data Cube und ordnet Streaming im Vergleich zu relationalen Datenbanksystemen ein. Zudem werden Kriterien vorgestellt und an dem Referenzmodell Aurora Borealis als Anwendung erläutert. Anschließend werden in Kapitel \ref{chapter:vorstellung} die einzelnen Streaming Frameworks vorgestellt. Dabei wird zu Beginn eine Kurzübersicht gegeben und anhand der Anwendung der Kriterien aus Kapitel \ref{chapter:kriterien} die ersten Gemeinsamkeiten, für die weitere Betrachtung in Kapitel \ref{chapter:systemarchitekur} festgestellt. In Kapitel \ref{chapter:vorstellung} werden alle notwendigen Methoden und Konzepte für die später zu erstellenden Prototypen erklärt und ausprobiert. Im Anhang dazu werden Beispiele für die Installation \ref{sec:storminstall}, \ref{section:kafkainstall}, \ref{section:flumeinstall}, \ref{sec:s4install} und für eine Demo-Anwendung \ref{section:quelltext} hinterlegt. Weiterhin wird bei jedem Streaming Framework die Client-Server-Kommunikation betrachtet und erklärt.

In Kapitel \ref{chapter:systemarchitekur} werden aufbauend auf den Erkenntnissen aus Kapitel \ref{chapter:vorstellung} Anforderungen definiert und daraus Lösungsansätze für erkannte Probleme vorgestellt. Dazu wird ein Systementwurf vorgestellt, indem in drei Ebenen das Backend, die Visualization und der Display eingeordnet werden. Weiterhin wird die Systemspezifikation, der Algorithmus zur Messung vorgestellt und das Vorgehen während der Implementierung der einzelnen Prototypen vorgestellt.

Das folgende Kapitel \ref{chapter:prototypeDocumentation} beschreibt den Aufbau und Struktur der Prototyp-Projekte. Dabei wird ebenso die Systemübersicht bestehend aus den einzelnen Streaming Framework Prototypen, Brokern, der WebServer und dem WebClient dargestellt und erläutert. Zudem wird auf die Implementierung der einzelnen Prototypen eingegangen, besondere Quelltextstellen vorgestellt und erklärt.

In Kapitel \ref{chapter:evaluierung} wird die Messumgebung beschrieben, die Messung durchgeführt und die Messergebnisse in Diagrammen vorgestellt und erläutert. Dabei wurden die Messergebnisse diskutiert und bewertet. Die unterschiedlichen Betrachtungen in der Bewertung ergeben eine Rangfolge als Ergebnis mit Apache Storm an erster Stelle, Apache Kafka an zweiter Stelle, Apache Flume an dritter Stelle und zuletzt Apache S4. Abschließend werden die Anforderungen aus Kapitel \ref{chapter:systemarchitekur} auf Einhaltung geprüft.

Der Prototyp Apache Storm erreicht die höchsten Werte während der Datenverarbeitung und setzt sich gegenüber den anderen Prototypen signifikant ab. Dadurch nimmt Apache Storm den ersten Platz in der Rangfolge ein. Apache Kafka verarbeitet mehr Daten, als Apache Flume bei etwa gleicher Prozessorauslastung. Damit ist Apache Kafka auf dem zweiten Platz. Apache S4 verarbeitet zwar mehr Daten als Apache Kafka hat aber im Vergleich die Prozessorauslastung wie bei Apache Storm. Im Verhältnis zwischen verarbeiteter Nachrichten pro Sekunde zur Prozessorauslastung fällt Apache S4 auf den vierten Platz. Damit ist Apache Flume auf dem dritten Platz.

Während der Entwicklung der Prototypen zeichnen sich die Streaming Frameworks Apache Storm, Apache Kafka und Apache Flume mit einer guten Dokumentation und einer aktiven Entwickler-Community aus. Bei Apache S4 ist die Entwickler-Community im Vergleich sehrklein und besteht aus den Hauptentwicklern. Zudem hat das Apache S4 Projekt auf der Apache Incubationseite den Status \textit{retired}. Ein retired kann aus mehreren gründen entstehen. Ein möglicher Grund könnte lange Zeitraum des letzten Commits in die Versionsverwatlung sein. Der aktuelle S4 Quellcode wird auf der Hauptseite bereitgestellt. Das Herunterladen wird mit einer Fehlermeldung beendet. Der Quelltext kann nur aus der Versionsverwaltung heruntergeladen werden. Im Gegensatz zu den anderen Streaming Frameworks befindet sich Apache S4 seit 2011 im Apache-Incubationsprozess.

Beim Debugging fällt Apache Storm aus der Reihe. Apache Storm unterstützt als einziges Streaming Framework ein lokales Debugging in der Entwicklungsumgebung. Alle anderen Prototypen müssen im Fehlerfall über das Logging-Framework Fehler aufzeichnen. Ein externes Monitoring muss daher die Aufzeichnungen überwachen.

In allen Prototypen konnte das Erstell- und Paketierungswerkzeug Apache Maven eingesetzt werden. Obwohl Apache S4 ein anderes Erstellungswerkzeug einsatz konnte eine geeignete Konfiguration in Apache Maven bereitgestellt werden. Dadurch kann eine Änderung im Quelltext der Prototypen mit einem Kommando bereitgestellt werden. Da Fehler nur über das Logging auffallen, müssen unter Umständen häufig neue Versionen bereitgestellt werden. Durch die konfigurierte Bereitstellung werden zudem mögliche Anwenderfehler während der Bereitstellung vermieden.

Apache Storm eignet sich für die dauerhafte Verarbeitung hoher Anzahl an Informationen. Speziell liefert die Methode der Topology eine schnelle Übersicht über die eingesetzten Verarbeitungseinheiten. Wenn eine Topology in einem Cluster, muss bei einer Änderung die ganze Topology gestoppt, entfernt und neu bereitgestellt werden. Damit Kafka-Clients mit Kafka-Server kommunizieren können, müssen die Maschinen-Namen im lokalen Domain Name System aufgelöst werden können.

Apache Kafka eignet sich für das Speichern von großen Datenmengen auf rotierenden Festplatten. Dabei werden optimierte Methoden aus dem Linux-Kern-Betriebssystem eingesetzt. Apache Kafka schreibt Informationen hintereinander weg. Daher eignet sich Apache Kafka als Logging-Persistenz.

In Apache Flume kann die Konfiguration zur Laufzeit verändert werden, wodurch eine hohe Flexibilität entsteht. Dennoch müssen für spezifische Anwendungen wie dem Apache Flume Prototypen eigene Implementierungen entwickelt werden. 

In Apache S4 müssen Anwendungen im Cluster bereitgestellt werden. Um eine Fehlerdiagnose durchzuführen, muss der einkompilierte Standard-Logger, durch Anpassung des Levels und erneutes Kompilieren verändert werden. Die Logger Information aus der Resource-Datei im Prototypen wird von Apache S4 nicht erkannt. Apache S4 wirkt durch das Patchen des Streaming Frameworks, um zum Beispiel Debug Log-Informationen auszugeben, noch prototypisch und nicht als ein Produktivsystem.


\section{Ausblick}

In diesem Kapitel werden mögliche Erweiterungen und Optimierungen vorgeschlagen. In der folgenden Liste werden dazu Maßnahmen  vorgestellt:

\textbf{\gls{glo:lrb}}
Damit ein Vergleich mit dem Referenzmodell Aurora Borealis möglich wird, wird eine Implementierung des \gls{glo:lrb} in Java benötigt. Dazu müssen anschließend die Prototypen entsprechend angepasst und erweitert werden.

\textbf{Unit-Test und Refactoring}
Mit guten Unit-Tests kann die Logik der einzelnen Prototypen abgesichert werden. Um den Quelltext wartbarer zu gestalten, können bestimmte Quelltextpassagen in separate Java-Archive ausgelagert werden.

\textbf{Continous-Integration}
Für ein einfaches Bereitstellen der Prototypen in einem Testsystem oder Livesystem, ist es notwendig die Prototypen automatisch vorher zu testen und anschließend erst bereitzustellen. Bei Fehlern in der Erstellung soll der fehlerhafte Quelltext nicht weiter bereitgestellt werden. Die Erstellung soll auf einer Übersichtsseite die gelaufene Erstellung entsprechend mit einer Fehlermeldung signalisieren und den Fehlerstapel ausgeben können.

\textbf{Optimierung}
In Apache Storm wird ein interner Transport von 1,00\e{6} Nachrichten pro Sekunde angegeben. Der Apache Storm Prototyp hat in der angegebenen Messung einen Höchstwert von 0,88\e{6} erreicht. Eine Optimierung des Quelltexts könnte eine Steigerung der Anzahl pro Sekunde in dem Prototypen liefern.

\textbf{Multi-Node-Cluster}
Die Messungen in dieser Arbeit sind auf ein Single-Node-Cluster bezogen. Die Ausführung auf einem Multi-Node-Cluster und die Berechnung mit dem \gls{glo:lrb} in Kombination, ist für die Bestimmung des \textit{L}-Index aus dem \gls{glo:lrb} interessant.

Durch die Erkenntnisse wird gezeigt, dass die Streaming Frameworks Apache Storm, Apache Kafka und Apache Flume permanent weiterentwickelt werden. Mit einer Weiterentwicklung der entsprechenden Prototypen in Hinsicht auf Stabilität und Performance durch Anwendung der vorgestellten Maßnahmen, kann eine Güte-Sicherung erreicht werden. Die Streaming Frameworks Apache Storm, Apache Kafka, Apache Flume sowie weitere Streaming Frameworks, können dadurch insgesamt einen Vorteil bekommen.
